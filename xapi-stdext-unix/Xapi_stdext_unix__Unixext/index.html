<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Xapi_stdext_unix__Unixext (xapi-stdext-unix.Xapi_stdext_unix__Unixext)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">xapi-stdext-unix</a> &#x00BB; Xapi_stdext_unix__Unixext</nav><h1>Module <code>Xapi_stdext_unix__Unixext</code></h1><p>A collection of extensions to the <code>Unix</code> module.</p></header><dl><dt class="spec external" id="val-_exit"><a href="#val-_exit" class="anchor"></a><code><span class="keyword">val</span> _exit : int <span>&#45;&gt;</span> unit</code></dt></dl><dl><dt class="spec value" id="val-unlink_safe"><a href="#val-unlink_safe" class="anchor"></a><code><span class="keyword">val</span> unlink_safe : string <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-mkdir_safe"><a href="#val-mkdir_safe" class="anchor"></a><code><span class="keyword">val</span> mkdir_safe : string <span>&#45;&gt;</span> Unix.file_perm <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-mkdir_rec"><a href="#val-mkdir_rec" class="anchor"></a><code><span class="keyword">val</span> mkdir_rec : string <span>&#45;&gt;</span> Unix.file_perm <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-pidfile_write"><a href="#val-pidfile_write" class="anchor"></a><code><span class="keyword">val</span> pidfile_write : string <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-pidfile_read"><a href="#val-pidfile_read" class="anchor"></a><code><span class="keyword">val</span> pidfile_read : string <span>&#45;&gt;</span> <span>int option</span></code></dt><dt class="spec value" id="val-daemonize"><a href="#val-daemonize" class="anchor"></a><code><span class="keyword">val</span> daemonize : unit <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-with_file"><a href="#val-with_file" class="anchor"></a><code><span class="keyword">val</span> with_file : string <span>&#45;&gt;</span> <span>Unix.open_flag list</span> <span>&#45;&gt;</span> Unix.file_perm <span>&#45;&gt;</span> <span>(Unix.file_descr <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-with_input_channel"><a href="#val-with_input_channel" class="anchor"></a><code><span class="keyword">val</span> with_input_channel : string <span>&#45;&gt;</span> <span>(Stdlib.in_channel <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-with_directory"><a href="#val-with_directory" class="anchor"></a><code><span class="keyword">val</span> with_directory : string <span>&#45;&gt;</span> <span>(Unix.dir_handle <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt></dl><dl><dt class="spec exception" id="exception-Break"><a href="#exception-Break" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Break</span></code></dt><dd><p>Exception to be raised in function to break out of <code>file_lines_fold</code>.</p></dd></dl><dl><dt class="spec value" id="val-lines_fold"><a href="#val-lines_fold" class="anchor"></a><code><span class="keyword">val</span> lines_fold : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> Stdlib.in_channel <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Folds function <code>f</code> over every line in the input channel</p></dd></dl><dl><dt class="spec value" id="val-lines_iter"><a href="#val-lines_iter" class="anchor"></a><code><span class="keyword">val</span> lines_iter : <span>(string <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> Stdlib.in_channel <span>&#45;&gt;</span> unit</code></dt><dd><p>Applies function <code>f</code> to every line in the input channel</p></dd></dl><dl><dt class="spec value" id="val-file_lines_fold"><a href="#val-file_lines_fold" class="anchor"></a><code><span class="keyword">val</span> file_lines_fold : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Folds function <code>f</code> over every line in the file at <code>file_path</code> using the starting value <code>start</code>.</p></dd></dl><dl><dt class="spec value" id="val-read_lines"><a href="#val-read_lines" class="anchor"></a><code><span class="keyword">val</span> read_lines : <span>path:string</span> <span>&#45;&gt;</span> <span>string list</span></code></dt><dd><p><code>read_lines path</code> returns a list of lines in the file at <code>path</code>.</p></dd></dl><dl><dt class="spec value" id="val-file_lines_iter"><a href="#val-file_lines_iter" class="anchor"></a><code><span class="keyword">val</span> file_lines_iter : <span>(string <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p>Applies function <code>f</code> to every line in the file at <code>file_path</code>.</p></dd></dl><dl><dt class="spec value" id="val-fd_blocks_fold"><a href="#val-fd_blocks_fold" class="anchor"></a><code><span class="keyword">val</span> fd_blocks_fold : int <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> Unix.file_descr <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fd_blocks_fold block_size f start fd</code> folds <code>f</code> over blocks (strings) from the fd <code>fd</code> with initial value <code>start</code></p></dd></dl><dl><dt class="spec value" id="val-readfile_line"><a href="#val-readfile_line" class="anchor"></a><code><span class="keyword">val</span> readfile_line : <span>(string <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p>Alias for function <code>file_lines_iter</code>.</p></dd></dl><dl><dt class="spec value" id="val-buffer_of_fd"><a href="#val-buffer_of_fd" class="anchor"></a><code><span class="keyword">val</span> buffer_of_fd : Unix.file_descr <span>&#45;&gt;</span> Stdlib.Buffer.t</code></dt><dd><p><code>buffer_of_fd fd</code> returns a Buffer.t containing all data read from <code>fd</code> up to EOF</p></dd></dl><dl><dt class="spec value" id="val-string_of_fd"><a href="#val-string_of_fd" class="anchor"></a><code><span class="keyword">val</span> string_of_fd : Unix.file_descr <span>&#45;&gt;</span> string</code></dt><dd><p><code>string_of_fd fd</code> returns a string containing all data read from <code>fd</code> up to EOF</p></dd></dl><dl><dt class="spec value" id="val-buffer_of_file"><a href="#val-buffer_of_file" class="anchor"></a><code><span class="keyword">val</span> buffer_of_file : string <span>&#45;&gt;</span> Stdlib.Buffer.t</code></dt><dd><p><code>buffer_of_file file</code> returns a Buffer.t containing the contents of <code>file</code></p></dd></dl><dl><dt class="spec value" id="val-string_of_file"><a href="#val-string_of_file" class="anchor"></a><code><span class="keyword">val</span> string_of_file : string <span>&#45;&gt;</span> string</code></dt><dd><p><code>string_of_file file</code> returns a string containing the contents of <code>file</code></p></dd></dl><dl><dt class="spec value" id="val-atomic_write_to_file"><a href="#val-atomic_write_to_file" class="anchor"></a><code><span class="keyword">val</span> atomic_write_to_file : string <span>&#45;&gt;</span> Unix.file_perm <span>&#45;&gt;</span> <span>(Unix.file_descr <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>atomic_write_to_file fname perms f</code> writes a file to path <code>fname</code> using the function <code>f</code> with permissions <code>perms</code>. In case of error during the operation the file with the path <code>fname</code> is not modified at all.</p></dd></dl><dl><dt class="spec value" id="val-write_string_to_file"><a href="#val-write_string_to_file" class="anchor"></a><code><span class="keyword">val</span> write_string_to_file : string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p><code>write_string_to_file fname contents</code> creates a file with path <code>fname</code> with the string <code>contents</code> as its contents, atomically</p></dd></dl><dl><dt class="spec value" id="val-write_bytes_to_file"><a href="#val-write_bytes_to_file" class="anchor"></a><code><span class="keyword">val</span> write_bytes_to_file : string <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> unit</code></dt><dd><p><code>write_string_to_file fname contents</code> creates a file with path <code>fname</code> with the buffer <code>contents</code> as its contents, atomically</p></dd></dl><dl><dt class="spec value" id="val-execv_get_output"><a href="#val-execv_get_output" class="anchor"></a><code><span class="keyword">val</span> execv_get_output : string <span>&#45;&gt;</span> <span>string array</span> <span>&#45;&gt;</span> int * Unix.file_descr</code></dt><dt class="spec value" id="val-copy_file"><a href="#val-copy_file" class="anchor"></a><code><span class="keyword">val</span> copy_file : <span>?&#8288;limit:int64</span> <span>&#45;&gt;</span> Unix.file_descr <span>&#45;&gt;</span> Unix.file_descr <span>&#45;&gt;</span> int64</code></dt><dt class="spec value" id="val-file_exists"><a href="#val-file_exists" class="anchor"></a><code><span class="keyword">val</span> file_exists : string <span>&#45;&gt;</span> bool</code></dt><dd><p>Returns true if and only if a file exists at the given path.</p></dd></dl><dl><dt class="spec value" id="val-touch_file"><a href="#val-touch_file" class="anchor"></a><code><span class="keyword">val</span> touch_file : string <span>&#45;&gt;</span> unit</code></dt><dd><p>Sets both the access and modification times of the file * at the given path to the current time. Creates an empty * file at the given path if no such file already exists.</p></dd></dl><dl><dt class="spec value" id="val-is_empty_file"><a href="#val-is_empty_file" class="anchor"></a><code><span class="keyword">val</span> is_empty_file : string <span>&#45;&gt;</span> bool</code></dt><dd><p>Returns true if and only if an empty file exists at the given path.</p></dd></dl><dl><dt class="spec value" id="val-delete_empty_file"><a href="#val-delete_empty_file" class="anchor"></a><code><span class="keyword">val</span> delete_empty_file : string <span>&#45;&gt;</span> bool</code></dt><dd><p>Safely deletes a file at the given path if (and only if) the * file exists and is empty. Returns true if a file was deleted.</p></dd></dl><dl><dt class="spec exception" id="exception-Host_not_found"><a href="#exception-Host_not_found" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Host_not_found</span> <span class="keyword">of</span> string</code></dt></dl><dl><dt class="spec value" id="val-open_connection_fd"><a href="#val-open_connection_fd" class="anchor"></a><code><span class="keyword">val</span> open_connection_fd : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> Unix.file_descr</code></dt><dt class="spec value" id="val-open_connection_unix_fd"><a href="#val-open_connection_unix_fd" class="anchor"></a><code><span class="keyword">val</span> open_connection_unix_fd : string <span>&#45;&gt;</span> Unix.file_descr</code></dt></dl><dl><dt class="spec exception" id="exception-Process_still_alive"><a href="#exception-Process_still_alive" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Process_still_alive</span></code></dt></dl><dl><dt class="spec value" id="val-kill_and_wait"><a href="#val-kill_and_wait" class="anchor"></a><code><span class="keyword">val</span> kill_and_wait : <span>?&#8288;signal:int</span> <span>&#45;&gt;</span> <span>?&#8288;timeout:float</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-string_of_signal"><a href="#val-string_of_signal" class="anchor"></a><code><span class="keyword">val</span> string_of_signal : int <span>&#45;&gt;</span> string</code></dt><dd><p><code>string_of_signal x</code> translates an ocaml signal number into * a string suitable for logging.</p></dd></dl><dl><dt class="spec value" id="val-proxy"><a href="#val-proxy" class="anchor"></a><code><span class="keyword">val</span> proxy : Unix.file_descr <span>&#45;&gt;</span> Unix.file_descr <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-really_read"><a href="#val-really_read" class="anchor"></a><code><span class="keyword">val</span> really_read : Unix.file_descr <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-really_read_string"><a href="#val-really_read_string" class="anchor"></a><code><span class="keyword">val</span> really_read_string : Unix.file_descr <span>&#45;&gt;</span> int <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-really_write"><a href="#val-really_write" class="anchor"></a><code><span class="keyword">val</span> really_write : Unix.file_descr <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p><code>really_write</code> keeps repeating the write operation until all bytes * have been written or an error occurs. This is not atomic but is * robust against EINTR errors. * See: https://ocaml.github.io/ocamlunix/ocamlunix.html#sec118</p></dd></dl><dl><dt class="spec value" id="val-really_write_string"><a href="#val-really_write_string" class="anchor"></a><code><span class="keyword">val</span> really_write_string : Unix.file_descr <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-try_read_string"><a href="#val-try_read_string" class="anchor"></a><code><span class="keyword">val</span> try_read_string : <span>?&#8288;limit:int</span> <span>&#45;&gt;</span> Unix.file_descr <span>&#45;&gt;</span> string</code></dt></dl><dl><dt class="spec exception" id="exception-Timeout"><a href="#exception-Timeout" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Timeout</span></code></dt></dl><dl><dt class="spec value" id="val-time_limited_write"><a href="#val-time_limited_write" class="anchor"></a><code><span class="keyword">val</span> time_limited_write : Unix.file_descr <span>&#45;&gt;</span> int <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> float <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-time_limited_write_substring"><a href="#val-time_limited_write_substring" class="anchor"></a><code><span class="keyword">val</span> time_limited_write_substring : Unix.file_descr <span>&#45;&gt;</span> int <span>&#45;&gt;</span> string <span>&#45;&gt;</span> float <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-time_limited_read"><a href="#val-time_limited_read" class="anchor"></a><code><span class="keyword">val</span> time_limited_read : Unix.file_descr <span>&#45;&gt;</span> int <span>&#45;&gt;</span> float <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-read_data_in_string_chunks"><a href="#val-read_data_in_string_chunks" class="anchor"></a><code><span class="keyword">val</span> read_data_in_string_chunks : <span>(string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span>?&#8288;block_size:int</span> <span>&#45;&gt;</span> <span>?&#8288;max_bytes:int</span> <span>&#45;&gt;</span> Unix.file_descr <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-read_data_in_chunks"><a href="#val-read_data_in_chunks" class="anchor"></a><code><span class="keyword">val</span> read_data_in_chunks : <span>(bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span>?&#8288;block_size:int</span> <span>&#45;&gt;</span> <span>?&#8288;max_bytes:int</span> <span>&#45;&gt;</span> Unix.file_descr <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-spawnvp"><a href="#val-spawnvp" class="anchor"></a><code><span class="keyword">val</span> spawnvp : <span>?&#8288;pid_callback:<span>(int <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span>string array</span> <span>&#45;&gt;</span> Unix.process_status</code></dt><dt class="spec value" id="val-double_fork"><a href="#val-double_fork" class="anchor"></a><code><span class="keyword">val</span> double_fork : <span>(unit <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> unit</code></dt></dl><dl><dt class="spec external" id="val-set_tcp_nodelay"><a href="#val-set_tcp_nodelay" class="anchor"></a><code><span class="keyword">val</span> set_tcp_nodelay : Unix.file_descr <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> unit</code></dt><dt class="spec external" id="val-set_sock_keepalives"><a href="#val-set_sock_keepalives" class="anchor"></a><code><span class="keyword">val</span> set_sock_keepalives : Unix.file_descr <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec external" id="val-fsync"><a href="#val-fsync" class="anchor"></a><code><span class="keyword">val</span> fsync : Unix.file_descr <span>&#45;&gt;</span> unit</code></dt><dt class="spec external" id="val-get_max_fd"><a href="#val-get_max_fd" class="anchor"></a><code><span class="keyword">val</span> get_max_fd : unit <span>&#45;&gt;</span> int</code></dt><dt class="spec external" id="val-blkgetsize64"><a href="#val-blkgetsize64" class="anchor"></a><code><span class="keyword">val</span> blkgetsize64 : Unix.file_descr <span>&#45;&gt;</span> int64</code></dt></dl><dl><dt class="spec value" id="val-int_of_file_descr"><a href="#val-int_of_file_descr" class="anchor"></a><code><span class="keyword">val</span> int_of_file_descr : Unix.file_descr <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-file_descr_of_int"><a href="#val-file_descr_of_int" class="anchor"></a><code><span class="keyword">val</span> file_descr_of_int : int <span>&#45;&gt;</span> Unix.file_descr</code></dt><dt class="spec value" id="val-close_all_fds_except"><a href="#val-close_all_fds_except" class="anchor"></a><code><span class="keyword">val</span> close_all_fds_except : <span>Unix.file_descr list</span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-resolve_dot_and_dotdot"><a href="#val-resolve_dot_and_dotdot" class="anchor"></a><code><span class="keyword">val</span> resolve_dot_and_dotdot : string <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-seek_to"><a href="#val-seek_to" class="anchor"></a><code><span class="keyword">val</span> seek_to : Unix.file_descr <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-seek_rel"><a href="#val-seek_rel" class="anchor"></a><code><span class="keyword">val</span> seek_rel : Unix.file_descr <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-current_cursor_pos"><a href="#val-current_cursor_pos" class="anchor"></a><code><span class="keyword">val</span> current_cursor_pos : Unix.file_descr <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-wait_for_path"><a href="#val-wait_for_path" class="anchor"></a><code><span class="keyword">val</span> wait_for_path : string <span>&#45;&gt;</span> <span>(float <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-send_fd"><a href="#val-send_fd" class="anchor"></a><code><span class="keyword">val</span> send_fd : Unix.file_descr <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>Unix.msg_flag list</span> <span>&#45;&gt;</span> Unix.file_descr <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-send_fd_substring"><a href="#val-send_fd_substring" class="anchor"></a><code><span class="keyword">val</span> send_fd_substring : Unix.file_descr <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>Unix.msg_flag list</span> <span>&#45;&gt;</span> Unix.file_descr <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-recv_fd"><a href="#val-recv_fd" class="anchor"></a><code><span class="keyword">val</span> recv_fd : Unix.file_descr <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>Unix.msg_flag list</span> <span>&#45;&gt;</span> int * Unix.sockaddr * Unix.file_descr</code></dt></dl><dl><dt class="spec type" id="type-statvfs_t"><a href="#type-statvfs_t" class="anchor"></a><code><span class="keyword">type</span> statvfs_t</code><code> = </code><code>{</code><table class="record"><tr id="type-statvfs_t.f_bsize" class="anchored"><td class="def field"><a href="#type-statvfs_t.f_bsize" class="anchor"></a><code>f_bsize : int64;</code></td></tr><tr id="type-statvfs_t.f_frsize" class="anchored"><td class="def field"><a href="#type-statvfs_t.f_frsize" class="anchor"></a><code>f_frsize : int64;</code></td></tr><tr id="type-statvfs_t.f_blocks" class="anchored"><td class="def field"><a href="#type-statvfs_t.f_blocks" class="anchor"></a><code>f_blocks : int64;</code></td></tr><tr id="type-statvfs_t.f_bfree" class="anchored"><td class="def field"><a href="#type-statvfs_t.f_bfree" class="anchor"></a><code>f_bfree : int64;</code></td></tr><tr id="type-statvfs_t.f_bavail" class="anchored"><td class="def field"><a href="#type-statvfs_t.f_bavail" class="anchor"></a><code>f_bavail : int64;</code></td></tr><tr id="type-statvfs_t.f_files" class="anchored"><td class="def field"><a href="#type-statvfs_t.f_files" class="anchor"></a><code>f_files : int64;</code></td></tr><tr id="type-statvfs_t.f_ffree" class="anchored"><td class="def field"><a href="#type-statvfs_t.f_ffree" class="anchor"></a><code>f_ffree : int64;</code></td></tr><tr id="type-statvfs_t.f_favail" class="anchored"><td class="def field"><a href="#type-statvfs_t.f_favail" class="anchor"></a><code>f_favail : int64;</code></td></tr><tr id="type-statvfs_t.f_fsid" class="anchored"><td class="def field"><a href="#type-statvfs_t.f_fsid" class="anchor"></a><code>f_fsid : int64;</code></td></tr><tr id="type-statvfs_t.f_flag" class="anchored"><td class="def field"><a href="#type-statvfs_t.f_flag" class="anchor"></a><code>f_flag : int64;</code></td></tr><tr id="type-statvfs_t.f_namemax" class="anchored"><td class="def field"><a href="#type-statvfs_t.f_namemax" class="anchor"></a><code>f_namemax : int64;</code></td></tr></table><code>}</code></dt></dl><dl><dt class="spec value" id="val-statvfs"><a href="#val-statvfs" class="anchor"></a><code><span class="keyword">val</span> statvfs : string <span>&#45;&gt;</span> <a href="index.html#type-statvfs_t">statvfs_t</a></code></dt><dt class="spec value" id="val-domain_of_addr"><a href="#val-domain_of_addr" class="anchor"></a><code><span class="keyword">val</span> domain_of_addr : string <span>&#45;&gt;</span> <span>Unix.socket_domain option</span></code></dt><dd><p>Returns Some Unix.PF_INET or Some Unix.PF_INET6 if passed a valid IP address, otherwise returns None.</p></dd></dl><div class="spec module" id="module-Direct"><a href="#module-Direct" class="anchor"></a><code><span class="keyword">module</span> <a href="Direct/index.html">Direct</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></div></body></html>