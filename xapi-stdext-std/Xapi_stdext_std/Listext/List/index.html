<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>List (xapi-stdext-std.Xapi_stdext_std.Listext.List)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../index.html">xapi-stdext-std</a> &#x00BB; <a href="../../index.html">Xapi_stdext_std</a> &#x00BB; <a href="../index.html">Listext</a> &#x00BB; List</nav><h1>Module <code>Listext.List</code></h1><nav class="toc"><ul><li><a href="#comparison">Comparison</a></li><li><a href="#iterators">Iterators</a></li><li><a href="#using-indices-to-manipulate-lists">Using indices to manipulate lists</a></li><li><a href="#association-lists">Association Lists</a></li><li><a href="#run-length-encoded-lists">Run-length encoded lists</a></li><li><a href="#generative-functions">Generative functions</a></li><li><a href="#lists-as-sets,-avoid">Lists as sets, avoid</a></li></ul></nav></header><section><header><h2 id="comparison"><a href="#comparison" class="anchor"></a>Comparison</h2></header><dl><dt class="spec value" id="val-is_sorted"><a href="#val-is_sorted" class="anchor"></a><code><span class="keyword">val</span> is_sorted : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_sorted cmp l</code> returns whether <code>l</code> is sorted according to <code>cmp</code>.</p></dd></dl></section><section><header><h2 id="iterators"><a href="#iterators" class="anchor"></a>Iterators</h2></header><dl><dt class="spec value" id="val-take"><a href="#val-take" class="anchor"></a><code><span class="keyword">val</span> take : int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>take n list</code> returns the first <code>n</code> elements of <code>list</code> (or less if list is shorter).</p></dd></dl><dl><dt class="spec value" id="val-drop"><a href="#val-drop" class="anchor"></a><code><span class="keyword">val</span> drop : int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>drop n list</code> returns the list without the first <code>n</code> elements of <code>list</code> (or <code></code> if list is shorter).</p></dd></dl><dl><dt class="spec value" id="val-rev_mapi"><a href="#val-rev_mapi" class="anchor"></a><code><span class="keyword">val</span> rev_mapi : <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span></code></dt><dd><p><code>rev_map f l</code> gives the same result as <span class="xref-unresolved" title="unresolved reference to &quot;Stdlib.List.rev&quot;"><span class="xref-unresolved" title="unresolved reference to &quot;Stdlib.List&quot;"><code>Stdlib</code>.List</span>.rev</span><code> (</code> <span class="xref-unresolved" title="unresolved reference to &quot;Stdlib.List.mapi&quot;"><span class="xref-unresolved" title="unresolved reference to &quot;Stdlib.List&quot;"><code>Stdlib</code>.List</span>.mapi</span><code> f l)</code>, but is tail-recursive and more efficient.</p></dd></dl><dl><dt class="spec value" id="val-map_tr"><a href="#val-map_tr" class="anchor"></a><code><span class="keyword">val</span> map_tr : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span></code></dt><dd><p><code>map_tr f l</code> is <span class="xref-unresolved" title="unresolved reference to &quot;Stdlib.List.rev&quot;"><span class="xref-unresolved" title="unresolved reference to &quot;Stdlib.List&quot;"><code>Stdlib</code>.List</span>.rev</span><code> (</code><span class="xref-unresolved" title="unresolved reference to &quot;Stdlib.List.rev_map&quot;"><span class="xref-unresolved" title="unresolved reference to &quot;Stdlib.List&quot;"><code>Stdlib</code>.List</span>.rev_map</span><code> f l)</code>.</p></dd></dl><dl><dt class="spec value" id="val-mapi_tr"><a href="#val-mapi_tr" class="anchor"></a><code><span class="keyword">val</span> mapi_tr : <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span></code></dt><dd><p><code>mapi_tr f l</code> is <span class="xref-unresolved" title="unresolved reference to &quot;Stdlib.List.rev&quot;"><span class="xref-unresolved" title="unresolved reference to &quot;Stdlib.List&quot;"><code>Stdlib</code>.List</span>.rev</span><code> (</code><a href="index.html#val-rev_mapi"><code>rev_mapi</code></a><code> f l)</code>.</p></dd></dl><dl><dt class="spec value" id="val-iteri_right"><a href="#val-iteri_right" class="anchor"></a><code><span class="keyword">val</span> iteri_right : <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-unbox_list"><a href="#val-unbox_list" class="anchor"></a><code><span class="keyword">val</span> unbox_list : <span><span><span class="type-var">'a</span> option</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p>Unbox all values from the option list.</p></dd></dl><dl><dt class="spec value" id="val-count"><a href="#val-count" class="anchor"></a><code><span class="keyword">val</span> count : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> int</code></dt><dd><p>Count the number of list elements matching the given predicate.</p></dd></dl><dl><dt class="spec value" id="val-position"><a href="#val-position" class="anchor"></a><code><span class="keyword">val</span> position : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span>int list</span></code></dt><dd><p>Find the indices of all elements matching the given predicate.</p></dd></dl></section><section><header><h2 id="using-indices-to-manipulate-lists"><a href="#using-indices-to-manipulate-lists" class="anchor"></a>Using indices to manipulate lists</h2></header><dl><dt class="spec value" id="val-chop"><a href="#val-chop" class="anchor"></a><code><span class="keyword">val</span> chop : int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>chop k l</code> splits <code>l</code> at index <code>k</code> to return a pair of lists. Raises invalid_arg when <code>i</code> is negative or greater than the length of <code>l</code>.</p></dd></dl><dl><dt class="spec value" id="val-rev_chop"><a href="#val-rev_chop" class="anchor"></a><code><span class="keyword">val</span> rev_chop : int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>rev_chop k l</code> splits <code>l</code> at index <code>k</code> to return a pair of lists, the first in reverse order. Raises invalid_arg when <code>i</code> is negative or greater than the length of <code>l</code>.</p></dd></dl><dl><dt class="spec value" id="val-chop_tr"><a href="#val-chop_tr" class="anchor"></a><code><span class="keyword">val</span> chop_tr : int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'a</span> list</span></code></dt><dd><p>Tail-recursive <a href="index.html#val-chop"><code>chop</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-dice"><a href="#val-dice" class="anchor"></a><code><span class="keyword">val</span> dice : int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> list</span></code></dt><dd><p><code>dice k l</code> splits <code>l</code> into lists with <code>k</code> elements each. Raises <code>Invalid_arg</code> if <code>List.length l</code> is not divisible by <code>k</code>.</p></dd></dl><dl><dt class="spec value" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span class="keyword">val</span> sub : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>sub from to l</code> returns the sub-list of <code>l</code> that starts at index <code>from</code> and ends at <code>to</code> or an empty list if <code>to</code> is equal or less than <code>from</code>. Negative indices are treated as 0 and indeces higher than <code>List.length l
      - 1</code> are treated as <code>List.length l - 1</code>.</p></dd></dl><dl><dt class="spec value" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span class="keyword">val</span> remove : int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p>Remove the element at the given index.</p></dd></dl><dl><dt class="spec value" id="val-insert"><a href="#val-insert" class="anchor"></a><code><span class="keyword">val</span> insert : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p>Insert the given element at the given index.</p></dd></dl><dl><dt class="spec value" id="val-replace"><a href="#val-replace" class="anchor"></a><code><span class="keyword">val</span> replace : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p>Replace the element at the given index with the given value.</p></dd></dl><dl><dt class="spec value" id="val-morph"><a href="#val-morph" class="anchor"></a><code><span class="keyword">val</span> morph : int <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p>Apply the given function to the element at the given index.</p></dd></dl></section><section><header><h2 id="association-lists"><a href="#association-lists" class="anchor"></a>Association Lists</h2></header><dl><dt class="spec value" id="val-make_assoc"><a href="#val-make_assoc" class="anchor"></a><code><span class="keyword">val</span> make_assoc : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></code></dt><dt class="spec value" id="val-assoc_default"><a href="#val-assoc_default" class="anchor"></a><code><span class="keyword">val</span> assoc_default : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p>Act as List.assoc, but return the given default value if the key is not in the list.</p></dd></dl><dl><dt class="spec value" id="val-replace_assoc"><a href="#val-replace_assoc" class="anchor"></a><code><span class="keyword">val</span> replace_assoc : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></code></dt><dd><p>Replace the value belonging to a key in an association list. Adds the key/value pair if it does not yet exist in the list. If the same key occurs multiple time in the original list, all occurances are removed and replaced by a single new key/value pair. This function is useful is the assoc list is used as a lightweight map/hashtable/dictonary.</p></dd></dl><dl><dt class="spec value" id="val-update_assoc"><a href="#val-update_assoc" class="anchor"></a><code><span class="keyword">val</span> update_assoc : <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></code></dt><dd><p>Includes everything from <code>update</code> and all key/value pairs from <code>existing</code> for which the key does not exist in <code>update</code>. In other words, it is like <code>replace_assoc</code> but then given a whole assoc list of updates rather than a single key/value pair.</p></dd></dl><dl><dt class="spec value" id="val-map_assoc_with_key"><a href="#val-map_assoc_with_key" class="anchor"></a><code><span class="keyword">val</span> map_assoc_with_key : <span>(<span class="type-var">'k</span> <span>&#45;&gt;</span> <span class="type-var">'v1</span> <span>&#45;&gt;</span> <span class="type-var">'v2</span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'k</span> * <span class="type-var">'v1</span>)</span> list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'k</span> * <span class="type-var">'v2</span>)</span> list</span></code></dt><dd><p><code>map_assoc_with_key op al</code> transforms every value in <code>al</code> based on the key and the value using <code>op</code>.</p></dd></dl><dl><dt class="spec value" id="val-inv_assoc"><a href="#val-inv_assoc" class="anchor"></a><code><span class="keyword">val</span> inv_assoc : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'b</span> * <span class="type-var">'a</span>)</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p>Perform a lookup on an association list of (value, key) pairs.</p></dd></dl><dl><dt class="spec value" id="val-restrict_with_default"><a href="#val-restrict_with_default" class="anchor"></a><code><span class="keyword">val</span> restrict_with_default : <span class="type-var">'v</span> <span>&#45;&gt;</span> <span><span class="type-var">'k</span> list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'k</span> * <span class="type-var">'v</span>)</span> list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'k</span> * <span class="type-var">'v</span>)</span> list</span></code></dt><dd><p><code>restrict_with_default default keys al</code> makes a new association map from <code>keys</code> to previous values for <code>keys</code> in <code>al</code>. If a key is not found in <code>al</code>, the <code>default</code> is used.</p></dd></dl></section><section><header><h2 id="run-length-encoded-lists"><a href="#run-length-encoded-lists" class="anchor"></a>Run-length encoded lists</h2><p>There are no known users of these functions.</p></header><dl><dt class="spec value" id="val-rle"><a href="#val-rle" class="anchor"></a><code><span class="keyword">val</span> rle : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * int)</span> list</span></code></dt><dd><p>Run-length encodes the given list using polimorphic equality</p></dd></dl><dl><dt class="spec value" id="val-unrle"><a href="#val-unrle" class="anchor"></a><code><span class="keyword">val</span> unrle : <span><span>(int * <span class="type-var">'a</span>)</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p>Decode a run-length encoded list.</p></dd></dl><dl><dt class="spec value" id="val-rle_eq"><a href="#val-rle_eq" class="anchor"></a><code><span class="keyword">val</span> rle_eq : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * int)</span> list</span></code></dt><dd><p><code>rle_eq eq l</code> run-length encodes <code>l</code> using <code>eq</code></p></dd></dl></section><section><header><h2 id="generative-functions"><a href="#generative-functions" class="anchor"></a>Generative functions</h2><p>These are usually useful for coding challenges like Advent of Code.</p></header><dl><dt class="spec value" id="val-range"><a href="#val-range" class="anchor"></a><code><span class="keyword">val</span> range : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>int list</span></code></dt><dd><p>range lower upper = <code>lower; lower + 1; ...; upper - 1</code> Returns the empty list if lower &gt;= upper. Consider building an <span class="xref-unresolved" title="unresolved reference to &quot;Stdlib.Seq&quot;"><code>Stdlib</code>.Seq</span>, it's more flexible</p></dd></dl><dl><dt class="spec value" id="val-between"><a href="#val-between" class="anchor"></a><code><span class="keyword">val</span> between : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>between e l</code> Intersperses <code>e</code> between elements of <code>l</code>.</p></dd></dl><dl><dt class="spec value" id="val-between_tr"><a href="#val-between_tr" class="anchor"></a><code><span class="keyword">val</span> between_tr : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p>Tail-recursive <a href="index.html#val-between"><code>between</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-randomize"><a href="#val-randomize" class="anchor"></a><code><span class="keyword">val</span> randomize : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p>Generate a random permutation of the given list.</p></dd></dl><dl><dt class="spec value" id="val-distribute"><a href="#val-distribute" class="anchor"></a><code><span class="keyword">val</span> distribute : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> list</span></code></dt><dd><p>Distribute the given element over the given list, returning a list of lists with the new element in each position.</p></dd></dl><dl><dt class="spec value" id="val-permute"><a href="#val-permute" class="anchor"></a><code><span class="keyword">val</span> permute : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> list</span></code></dt><dd><p>Generate all permutations of the given list.</p></dd></dl><dl><dt class="spec value" id="val-inner"><a href="#val-inner" class="anchor"></a><code><span class="keyword">val</span> inner : <span>(<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'e</span> <span>&#45;&gt;</span> <span class="type-var">'f</span> <span>&#45;&gt;</span> <span class="type-var">'g</span> <span>&#45;&gt;</span> <span class="type-var">'h</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'e</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'i</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'f</span> <span>&#45;&gt;</span> <span class="type-var">'g</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'i</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'h</span></code></dt><dd><p>Compute the inner product of two lists.</p></dd></dl><dl><dt class="spec value" id="val-tails"><a href="#val-tails" class="anchor"></a><code><span class="keyword">val</span> tails : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> list</span></code></dt></dl></section><section><header><h2 id="lists-as-sets,-avoid"><a href="#lists-as-sets,-avoid" class="anchor"></a>Lists as sets, avoid</h2><p>Please use Set.Make instead, these functions have quadratic costs!</p></header><dl><dt class="spec value" id="val-setify"><a href="#val-setify" class="anchor"></a><code><span class="keyword">val</span> setify : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>setify a</code> removes all duplicates from <code>a</code> while maintaining order. Please use <code>List.sort_uniq</code> instead to deduplicate lists if possible</p></dd></dl><dl><dt class="spec value" id="val-subset"><a href="#val-subset" class="anchor"></a><code><span class="keyword">val</span> subset : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>subset a b</code> returns whether all elements in <code>b</code> can be found in <code>a</code></p></dd></dl><dl><dt class="spec value" id="val-set_equiv"><a href="#val-set_equiv" class="anchor"></a><code><span class="keyword">val</span> set_equiv : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-set_difference"><a href="#val-set_difference" class="anchor"></a><code><span class="keyword">val</span> set_difference : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p>Returns the set difference of two lists</p></dd></dl><dl><dt class="spec value" id="val-intersect"><a href="#val-intersect" class="anchor"></a><code><span class="keyword">val</span> intersect : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p>Returns the intersection of two lists.</p></dd></dl></section></div></body></html>