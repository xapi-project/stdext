<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>List (xapi-stdext-std.Xapi_stdext_std.Listext.List)</title><link rel="stylesheet" href="../../../../_odoc_support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">xapi-stdext-std</a> &#x00BB; <a href="../../index.html">Xapi_stdext_std</a> &#x00BB; <a href="../index.html">Listext</a> &#x00BB; List</nav><header class="odoc-preamble"><h1>Module <code><span>Listext.List</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#comparison">Comparison</a></li><li><a href="#iterators">Iterators</a></li><li><a href="#using-indices-to-manipulate-lists">Using indices to manipulate lists</a></li><li><a href="#association-lists">Association Lists</a></li><li><a href="#run-length-encoded-lists">Run-length encoded lists</a></li><li><a href="#generative-functions">Generative functions</a></li><li><a href="#lists-as-sets,-avoid">Lists as sets, avoid</a></li></ul></nav><div class="odoc-content"><h2 id="comparison"><a href="#comparison" class="anchor"></a>Comparison</h2><div class="odoc-spec"><div class="spec value" id="val-is_sorted" class="anchored"><a href="#val-is_sorted" class="anchor"></a><code><span><span class="keyword">val</span> is_sorted : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_sorted cmp l</code> returns whether <code>l</code> is sorted according to <code>cmp</code>.</p></div></div><h2 id="iterators"><a href="#iterators" class="anchor"></a>Iterators</h2><div class="odoc-spec"><div class="spec value" id="val-take" class="anchored"><a href="#val-take" class="anchor"></a><code><span><span class="keyword">val</span> take : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>take n list</code> returns the first <code>n</code> elements of <code>list</code> (or less if list is shorter).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-drop" class="anchored"><a href="#val-drop" class="anchor"></a><code><span><span class="keyword">val</span> drop : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>drop n list</code> returns the list without the first <code>n</code> elements of <code>list</code> (or  if list is shorter).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rev_mapi" class="anchored"><a href="#val-rev_mapi" class="anchor"></a><code><span><span class="keyword">val</span> rev_mapi : <span><span>( <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>rev_map f l</code> gives the same result as <code>Stdlib</code>.List.rev<code> (</code> <code>Stdlib</code>.List.mapi<code> f l)</code>, but is tail-recursive and more efficient.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-map_tr" class="anchored"><a href="#val-map_tr" class="anchor"></a><code><span><span class="keyword">val</span> map_tr : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>map_tr f l</code> is <code>Stdlib</code>.List.rev<code> (</code><code>Stdlib</code>.List.rev_map<code> f l)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mapi_tr" class="anchored"><a href="#val-mapi_tr" class="anchor"></a><code><span><span class="keyword">val</span> mapi_tr : <span><span>( <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>mapi_tr f l</code> is <code>Stdlib</code>.List.rev<code> (</code><a href="#val-rev_mapi"><code>rev_mapi</code></a><code> f l)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unbox_list" class="anchored"><a href="#val-unbox_list" class="anchor"></a><code><span><span class="keyword">val</span> unbox_list : <span><span><span><span class="type-var">'a</span> option</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Unbox all values from the option list.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-count" class="anchored"><a href="#val-count" class="anchor"></a><code><span><span class="keyword">val</span> count : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Count the number of list elements matching the given predicate.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-position" class="anchored"><a href="#val-position" class="anchor"></a><code><span><span class="keyword">val</span> position : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>int list</span></span></code></div><div class="spec-doc"><p>Find the indices of all elements matching the given predicate.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iteri_right" class="anchored"><a href="#val-iteri_right" class="anchor"></a><code><span><span class="keyword">val</span> iteri_right : <span><span>( <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iteri_right f l</code> is <code>Stdlib</code>.List.iteri<code> f (</code><code>Stdlib</code>.List.rev<code> l)</code></p></div></div><h2 id="using-indices-to-manipulate-lists"><a href="#using-indices-to-manipulate-lists" class="anchor"></a>Using indices to manipulate lists</h2><div class="odoc-spec"><div class="spec value" id="val-chop" class="anchored"><a href="#val-chop" class="anchor"></a><code><span><span class="keyword">val</span> chop : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>chop k l</code> splits <code>l</code> at index <code>k</code> to return a pair of lists. Raises invalid_arg when <code>i</code> is negative or greater than the length of <code>l</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rev_chop" class="anchored"><a href="#val-rev_chop" class="anchor"></a><code><span><span class="keyword">val</span> rev_chop : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>rev_chop k l</code> splits <code>l</code> at index <code>k</code> to return a pair of lists, the first in reverse order. Raises invalid_arg when <code>i</code> is negative or greater than the length of <code>l</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-chop_tr" class="anchored"><a href="#val-chop_tr" class="anchor"></a><code><span><span class="keyword">val</span> chop_tr : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Tail-recursive <a href="#val-chop"><code>chop</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dice" class="anchored"><a href="#val-dice" class="anchor"></a><code><span><span class="keyword">val</span> dice : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> list</span></span></code></div><div class="spec-doc"><p><code>dice k l</code> splits <code>l</code> into lists with <code>k</code> elements each. Raises <code>Invalid_arg</code> if <code>List.length l</code> is not divisible by <code>k</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sub" class="anchored"><a href="#val-sub" class="anchor"></a><code><span><span class="keyword">val</span> sub : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>sub from to l</code> returns the sub-list of <code>l</code> that starts at index <code>from</code> and ends at <code>to</code> or an empty list if <code>to</code> is equal or less than <code>from</code>. Negative indices are treated as 0 and indeces higher than <code>List.length l
      - 1</code> are treated as <code>List.length l - 1</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-remove" class="anchored"><a href="#val-remove" class="anchor"></a><code><span><span class="keyword">val</span> remove : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Remove the element at the given index.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-insert" class="anchored"><a href="#val-insert" class="anchor"></a><code><span><span class="keyword">val</span> insert : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Insert the given element at the given index.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-replace" class="anchored"><a href="#val-replace" class="anchor"></a><code><span><span class="keyword">val</span> replace : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Replace the element at the given index with the given value.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-morph" class="anchored"><a href="#val-morph" class="anchor"></a><code><span><span class="keyword">val</span> morph : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Apply the given function to the element at the given index.</p></div></div><h2 id="association-lists"><a href="#association-lists" class="anchor"></a>Association Lists</h2><div class="odoc-spec"><div class="spec value" id="val-make_assoc" class="anchored"><a href="#val-make_assoc" class="anchor"></a><code><span><span class="keyword">val</span> make_assoc : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-assoc_default" class="anchored"><a href="#val-assoc_default" class="anchor"></a><code><span><span class="keyword">val</span> assoc_default : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p>Act as List.assoc, but return the given default value if the key is not in the list.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-replace_assoc" class="anchored"><a href="#val-replace_assoc" class="anchor"></a><code><span><span class="keyword">val</span> replace_assoc : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></span></code></div><div class="spec-doc"><p>Replace the value belonging to a key in an association list. Adds the key/value pair if it does not yet exist in the list. If the same key occurs multiple time in the original list, all occurances are removed and replaced by a single new key/value pair. This function is useful is the assoc list is used as a lightweight map/hashtable/dictonary.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-update_assoc" class="anchored"><a href="#val-update_assoc" class="anchor"></a><code><span><span class="keyword">val</span> update_assoc : <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></span></code></div><div class="spec-doc"><p>Includes everything from <code>update</code> and all key/value pairs from <code>existing</code> for which the key does not exist in <code>update</code>. In other words, it is like <code>replace_assoc</code> but then given a whole assoc list of updates rather than a single key/value pair.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-map_assoc_with_key" class="anchored"><a href="#val-map_assoc_with_key" class="anchor"></a><code><span><span class="keyword">val</span> map_assoc_with_key : 
  <span><span>( <span><span class="type-var">'k</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'v1</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'v2</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'k</span> * <span class="type-var">'v1</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'k</span> * <span class="type-var">'v2</span>)</span> list</span></span></code></div><div class="spec-doc"><p><code>map_assoc_with_key op al</code> transforms every value in <code>al</code> based on the key and the value using <code>op</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-inv_assoc" class="anchored"><a href="#val-inv_assoc" class="anchor"></a><code><span><span class="keyword">val</span> inv_assoc : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span> * <span class="type-var">'a</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p>Perform a lookup on an association list of (value, key) pairs.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-restrict_with_default" class="anchored"><a href="#val-restrict_with_default" class="anchor"></a><code><span><span class="keyword">val</span> restrict_with_default : <span><span class="type-var">'v</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'k</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'k</span> * <span class="type-var">'v</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'k</span> * <span class="type-var">'v</span>)</span> list</span></span></code></div><div class="spec-doc"><p><code>restrict_with_default default keys al</code> makes a new association map from <code>keys</code> to previous values for <code>keys</code> in <code>al</code>. If a key is not found in <code>al</code>, the <code>default</code> is used.</p></div></div><h2 id="run-length-encoded-lists"><a href="#run-length-encoded-lists" class="anchor"></a>Run-length encoded lists</h2><p>There are no known users of these functions.</p><h2 id="generative-functions"><a href="#generative-functions" class="anchor"></a>Generative functions</h2><p>These are usually useful for coding challenges like Advent of Code.</p><div class="odoc-spec"><div class="spec value" id="val-range" class="anchored"><a href="#val-range" class="anchor"></a><code><span><span class="keyword">val</span> range : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int list</span></span></code></div><div class="spec-doc"><p>range lower upper = <code>lower; lower + 1; ...; upper - 1</code> Returns the empty list if lower &gt;= upper. Consider building an <code>Stdlib</code>.Seq, it's more flexible</p></div></div><div class="odoc-spec"><div class="spec value" id="val-between" class="anchored"><a href="#val-between" class="anchor"></a><code><span><span class="keyword">val</span> between : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>between e l</code> Intersperses <code>e</code> between elements of <code>l</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-between_tr" class="anchored"><a href="#val-between_tr" class="anchor"></a><code><span><span class="keyword">val</span> between_tr : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Tail-recursive <a href="#val-between"><code>between</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-inner" class="anchored"><a href="#val-inner" class="anchor"></a><code><span><span class="keyword">val</span> inner : 
  <span><span>( <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'d</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'e</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'f</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'g</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'h</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'e</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'i</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'f</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'g</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'i</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'d</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'h</span></span></code></div><div class="spec-doc"><p>Compute the inner product of two lists.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tails" class="anchored"><a href="#val-tails" class="anchor"></a><code><span><span class="keyword">val</span> tails : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> list</span></span></code></div></div><h2 id="lists-as-sets,-avoid"><a href="#lists-as-sets,-avoid" class="anchor"></a>Lists as sets, avoid</h2><p>Please use Set.Make instead, these functions have quadratic costs!</p><div class="odoc-spec"><div class="spec value" id="val-setify" class="anchored"><a href="#val-setify" class="anchor"></a><code><span><span class="keyword">val</span> setify : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>setify a</code> removes all duplicates from <code>a</code> while maintaining order. Please use <code>List.sort_uniq</code> instead to deduplicate lists if possible</p></div></div><div class="odoc-spec"><div class="spec value" id="val-subset" class="anchored"><a href="#val-subset" class="anchor"></a><code><span><span class="keyword">val</span> subset : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>subset a b</code> returns whether all elements in <code>b</code> can be found in <code>a</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_equiv" class="anchored"><a href="#val-set_equiv" class="anchor"></a><code><span><span class="keyword">val</span> set_equiv : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-set_difference" class="anchored"><a href="#val-set_difference" class="anchor"></a><code><span><span class="keyword">val</span> set_difference : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Returns the set difference of two lists</p></div></div><div class="odoc-spec"><div class="spec value" id="val-intersect" class="anchored"><a href="#val-intersect" class="anchor"></a><code><span><span class="keyword">val</span> intersect : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Returns the intersection of two lists.</p></div></div></div></body></html>